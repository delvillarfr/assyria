%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Assyria Documentation}
\date{Dec 05, 2017}
\release{0.1}
\author{Hortacsu}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Estimation}
\label{\detokenize{index:welcome-to-assyria-s-documentation}}\label{\detokenize{index:estimation}}\index{Estimate (class in estimate)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{estimate.}\sphinxbfcode{Estimate}}{\emph{build\_type}, \emph{lat=(36}, \emph{42)}, \emph{lng=(27}, \emph{45)}}{}~\index{export\_results() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.export_results}}\pysiglinewithargsret{\sphinxbfcode{export\_results}}{\emph{varlist}}{}
varlist is in jhwi format:
(zeta, useless, long\_known, long\_unknown, lat\_known, lat\_unknown, a)
Exports zeta.csv, coordinates.csv, cities.csv, simulation.csv

\end{fulllineitems}

\index{fetch\_dist() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.fetch_dist}}\pysiglinewithargsret{\sphinxbfcode{fetch\_dist}}{\emph{lat\_guess}, \emph{lng\_guess}, \emph{full\_vars=False}}{}
Wrapper

\end{fulllineitems}

\index{full\_to\_short\_i() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.full_to_short_i}}\pysiglinewithargsret{\sphinxbfcode{full\_to\_short\_i}}{}{}
returns the indices to select short varlist from full varlist

\end{fulllineitems}

\index{gen\_data() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.gen_data}}\pysiglinewithargsret{\sphinxbfcode{gen\_data}}{\emph{len\_sim}, \emph{perturb}, \emph{rank=None}, \emph{full\_vars=False}}{}
rank: int. Process number in parallelized computing.
Returns simulation dataframe sorted by objective value

\end{fulllineitems}

\index{get\_best\_result() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_best_result}}\pysiglinewithargsret{\sphinxbfcode{get\_best\_result}}{\emph{results}}{}
results: pd.DataFrame. It is the output of the parallelized execution.
returns the row with minimum objective function value.

\end{fulllineitems}

\index{get\_bounds() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_bounds}}\pysiglinewithargsret{\sphinxbfcode{get\_bounds}}{\emph{constr}, \emph{full\_vars=False}}{}
Returns (lb, ub), where lb and ub are lists for the bounds.

\end{fulllineitems}

\index{get\_coordinate\_pairs() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_coordinate_pairs}}\pysiglinewithargsret{\sphinxbfcode{get\_coordinate\_pairs}}{\emph{lat\_guess}, \emph{lng\_guess}, \emph{full\_vars=False}}{}
full\_vars: bool. If True, the known coordinates are included as
variables of the objective and gradient.

This is an alternative implementation of the fetching distance process,

Leverages the fact that the iticount data is sorted according to
id\_jhwi\_j first, then by id\_jhwi\_i, and the coordinates are sorted
according to id\_jhwi.

\end{fulllineitems}

\index{get\_errors() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_errors}}\pysiglinewithargsret{\sphinxbfcode{get\_errors}}{\emph{varlist}, \emph{full\_vars=False}}{}
varlist = np.array({[}zeta, alpha, lat\_guess, lng\_guess{]}).

Returns the difference of data and model trade shares.

\end{fulllineitems}

\index{get\_size() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_size}}\pysiglinewithargsret{\sphinxbfcode{get\_size}}{\emph{zeta}, \emph{alpha}, \emph{distances}, \emph{scale\_kanes=False}, \emph{theta=4.0}}{}~\begin{description}
\item[{Returns the fundamental size of cities:}] \leavevmode
Size\_i proportional to L\_i T\_i\textasciicircum{}(1/theta)

\end{description}

\end{fulllineitems}

\index{get\_size\_variance() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_size_variance}}\pysiglinewithargsret{\sphinxbfcode{get\_size\_variance}}{\emph{varlist}, \emph{scale\_kanes=False}, \emph{var\_type='white'}}{}
Applies Delta Method to get the variance-covariance matrix of the city
size estimates.

Return the variance-covariance matrix of sizes.

\end{fulllineitems}

\index{get\_variance() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_variance}}\pysiglinewithargsret{\sphinxbfcode{get\_variance}}{\emph{varlist}, \emph{var\_type='white'}, \emph{full\_vars=False}}{}
Computes the variance-covariance matrix of the estimators according to
the white formula. (see paper)

\end{fulllineitems}

\index{get\_variance\_gmm() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.get_variance_gmm}}\pysiglinewithargsret{\sphinxbfcode{get\_variance\_gmm}}{\emph{varlist}, \emph{full\_vars=False}}{}
Computes the variance-covariance matrix of the estimators according to
the GMM formula. (see notes.pdf)

\end{fulllineitems}

\index{haversine\_approx() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.haversine_approx}}\pysiglinewithargsret{\sphinxbfcode{haversine\_approx}}{\emph{coord\_i}, \emph{coord\_j}}{}
coord\_i, coord\_j: np.array. 2 columns, len(iticount) rows. First column
(column 0) is latitude, second column (column 1) is longitude.

Returns the approximation of the Haversine formula described in the
estimation section of the paper.

\end{fulllineitems}

\index{initial\_cond() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.initial_cond}}\pysiglinewithargsret{\sphinxbfcode{initial\_cond}}{\emph{len\_sim=None}, \emph{perturb=None}, \emph{full\_vars=False}}{}
len\_sim: int. Specifies the number of draws to take.
perturb: float. Specifies a percentage deviation from the default
initial value.

Returns default initial condition if perturb is not specified, and an
array of perturbed values of dimension (len\_sim, numvars)

\end{fulllineitems}

\index{output\_to\_jhwi() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.output_to_jhwi}}\pysiglinewithargsret{\sphinxbfcode{output\_to\_jhwi}}{\emph{output}}{}
Returns the initial value to evaluate the MATLAB objective function.

\end{fulllineitems}

\index{replace\_id\_coord() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.replace_id_coord}}\pysiglinewithargsret{\sphinxbfcode{replace\_id\_coord}}{\emph{constr}, \emph{drop\_wahsusana=False}}{}
constr: pd.DataFrame. Specifies upper and lower bounds for
coordinates of cities.

Replaces the city id with its corresponding latitudes and longitudes in
the constraints datasets.

\end{fulllineitems}

\index{resolve() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.resolve}}\pysiglinewithargsret{\sphinxbfcode{resolve}}{\emph{result}}{}
result: pd.DataFrame. Output of self.get\_best\_result

Recursively digs into the coordinates results if the maximum number of
iterations was reached. Otherwise it returns the best solution.

\end{fulllineitems}

\index{s\_ij\_model() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.s_ij_model}}\pysiglinewithargsret{\sphinxbfcode{s\_ij\_model}}{\emph{zeta}, \emph{alpha}, \emph{distances}}{}
zeta: float. The distance elasticity of trade.
alpha: np.array. One for each importing city.
distances: np.array. Contains distances between all j, i pairs,
excluding j, j pairs.

Idea: cast elements as matrix, add over axis=0,
repeat (number of cities - 1), divide elements by this new 1-dim array.

Returns np.array: the model-predicted trade shares

\end{fulllineitems}

\index{simulate\_contour\_data() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.simulate_contour_data}}\pysiglinewithargsret{\sphinxbfcode{simulate\_contour\_data}}{\emph{varlist}, \emph{size=20000}, \emph{var\_type='white'}, \emph{full\_vars=False}}{}
varlist is taken to be the point estimate vector.

Gets the var\_type variance matrix using varlist and simulates size
draws from a normal distribution with mean varlist and variance.

\end{fulllineitems}

\index{solve() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.solve}}\pysiglinewithargsret{\sphinxbfcode{solve}}{\emph{x0}, \emph{constraint\_type='static'}, \emph{full\_vars=False}}{}
x0: list. It is the initial value.
constraint\_type: str. One of ‘static’ or ‘dynamic’.
Returns a one-row dataframe with optimization information.

\end{fulllineitems}

\index{sqerr\_sum() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.sqerr_sum}}\pysiglinewithargsret{\sphinxbfcode{sqerr\_sum}}{\emph{varlist}, \emph{full\_vars=False}}{}
Returns the value of the objective function given the data and the
model trade shares.

\end{fulllineitems}

\index{tile\_nodiag() (estimate.Estimate method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:estimate.Estimate.tile_nodiag}}\pysiglinewithargsret{\sphinxbfcode{tile\_nodiag}}{\emph{arr}}{}
arr: np.array. A 1-dim array of length self.num\_cities.

Returns an array repeating arr the number of times given by
self.num\_cities, but extracting value in index j on repetition j.

example: If arr = np.array({[}1, 2, 3{]}) then self.tile\_nodiag(arr) returns
np.array({[}2, 3, 1, 3, 1, 2{]}).

\end{fulllineitems}


\end{fulllineitems}




\renewcommand{\indexname}{Index}
\printindex
\end{document}